### Списки

Операции создания списка и добавления элемента в него

```f#
let vowels = ['a'; 'e', 'i', 'o'; 'u']
let sometimes = 'y' :: vowels
// ['y'; 'a'; 'e'; 'i'; 'o'; 'u']
```

Можно складывать списки с помощью оператора `@`

```f#
let odds = [1; 3; 5; 7; 9]
let evens = [2; 4; 6; 8; 10]
let all = odds @ evens
// [1; 3; 5; 7; 9; 2; 4; 6; 8; 10]
```

Создание списка указанием диапазона

```f#
let x = [1 .. 10]
// [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
                               
let tens = [0 .. 10 .. 50]
// [0; 10; 20; 30; 40; 50]

let countDown = [5L .. -1L .. 0L]
// [5L; 4L; 3L; 2L; 1L; 0L]
```

Генераторы списков (list comprehensions)

```f#
let near x =
    [
        yield x-1
        yield x
        yield x+1
    ]
near 3
// [2; 3; 4]    
```

Можно генерировать списки с помощью `for`:

```f#
let multiples x = [ for i in 1 .. 10 -> x * i ]
```

Модуль List

| Функция        | Тип | Описание
|----------------|-----|---------
| List.length    | 'a list -> int | Длина списка
| List.head      | 'a list -> 'a  | Первый элемент списка
| List.tail      | 'a list -> 'a  | Список без первого элемента
| List.exists    | ('a -> bool) -> 'a list -> bool | Есть ли в списке хоть один элемент, удовлетворяющий заданному условию
| List.rev       | 'a list -> 'a list | Меняет порядок элементов в списке на противоположный
| List.tryfind   | ('a -> bool) -> 'a list -> 'a option | Находит первый элемент списка, удовлетворяющий условию, либо None
| List.zip       | 'a list -> 'b list -> ('a * 'b) list | Сшивает два списка в список кортежей
| List.filter    | ('a -> bool) -> 'a list -> 'a list | Отбирает из списка только те значения, для которых выполняется указанное условие
| List.partition | ('a -> bool) -> 'a list -> ('a list * 'a list) | Разбивает список на два: в первом те элементы, для которых указанное условие выполняется, во втором - те, для которых условие не выполняется

Функция `List.map` выполняет операцию проекции

```f#
let square x = x * x
let squares = List.map square [1 .. 10]
// [1; 4; 9; 16; 25; 36; 49; 64; 81; 100
``` 

Функция `List.reduce` применяет указанную агрегирующую функцию. Агрегат того же типа, что и элементы списка

```f#
let comma x y = x + ", " + y
let snacks = ["изюм"; "орехи"; "шоколад"]
List.reduce comma snacks
// "изюм, орехи, шоколад"
```

Есть полностью аналогичная функция `List.reduceBack`, которая отличается лишь тем, что выполняет свертку справа налево.

Функция `List.fold` также применяет указанную агрегирующую функцию, только агрегат может быть произвольного типа

```f#
let sumLen acc (x: string) = acc + x.Length
let snacks = ["изюм"; "орехи"; "шоколад"]
List.fold sumLen 0 snacks
// 16
```

Есть полностью аналогичная функция `List.foldBack`, которая отличается лишь тем, что выполняет свертку справа налево.

Оператор `List.iter` проходит по всем элементам списка и вызывает указанную функцию

```f#
List.iter (printf "%d ") [1..10]
```
